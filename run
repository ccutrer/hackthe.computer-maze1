#!/usr/bin/env ruby

require 'set'
require_relative 'priority_queue'

class AStar
  def initialize(adjacency_func, cost_func, distance_func)
    @adjacency = adjacency_func
    @cost = cost_func
    @distance = distance_func
  end

  def find_path(start, goal)
    been_there = Set.new
    pqueue = Containers::PriorityQueue.new
    pqueue.push([start, [], 0], 1)
    while !pqueue.empty?
      spot, path_so_far, cost_so_far = pqueue.pop
      next if been_there.include?(spot)
      newpath = path_so_far + [spot]
      if (spot == goal)
        return newpath
      end
      been_there << spot
      @adjacency.call(spot).each do |newspot|
        next if been_there.include?(newspot)
        newcost = cost_so_far + 1
        pqueue.push([newspot, newpath, newcost],
                    -@distance.call(goal, newspot))
      end
    end
    return nil
  end
end


file = $stdin
file = File.open(ARGV.first) unless ARGV.empty?
map = file.readlines.map(&:strip)

def find(map, target)
  map.each_with_index do |row, i|
    j = row.index(target)
    return [j, i] if j
  end
end

start = find(map, 'F')
finish = find(map, 'S')

adjacency = ->(location) do
  [
    [location.first - 1, location.last],
    [location.first, location.last - 1],
    [location.first + 1, location.last],
    [location.first, location.last + 1]
  ].select do |new_location|
    new_location.first >= 0 && new_location.last >= 0 &&
    new_location.first < map.first.length && new_location.last < map.length &&
    ['S', '-', 'F'].include?(map[new_location.last][new_location.first])
  end
end

cost_func = ->(a, b) { 1 }
distance_func = ->(location, finish) do
  Math.sqrt((finish.last - location.last) ** 2 + (finish.first - location.first) ** 2)
end

astar = AStar.new(adjacency, cost_func, distance_func)

path = astar.find_path(start, finish)

exit unless path

path = path.reverse
path.each_with_index do |now, index|
  next if index == 0
  last = path[index - 1]
  if now.first > last.first
    puts 'E'
  elsif now.last > last.last
    puts 'S'
  elsif now.first < last.first
    puts 'W'
  else
    puts 'N'
  end
end

